// Copyright 2010 Christophe Henry
// henry UNDERSCORE christophe AT hotmail DOT com
// This is an extended version of the state machine available in the boost::mpl library
// Distributed under the same license as the original.
// Copyright for the original version:
// Copyright 2005 David Abrahams and Aleksey Gurtovoy. Distributed
// under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// statechart: http://www.boost.org/doc/libs/1_60_0/libs/msm/doc/images/SimpleTutorial.jpg
#include "Boost_MSM_SM.h"

using namespace BlindsSm;

void test()
{
   // statechart: http://www.boost.org/doc/libs/1_60_0/libs/msm/doc/images/SimpleTutorial.jpg
   blind _blind;
   // needed to start the highest-level SM. This will call on_entry and mark the start of the SM
   _blind.start();
   // go to Open, call on_exit on Empty, then action, then on_entry on Open
   _blind.process_event(open_close);
   pstate(_blind);
   _blind.process_event(open_close);
   pstate(_blind);
   // will be rejected, wrong disk type
   _blind.process_event(cd_detected_event("louie, louie", PlayerSm::DISK_DVD));
   pstate(_blind);
   _blind.process_event(cd_detected_event("louie, louie", PlayerSm::DISK_CD));
   pstate(_blind);
   // no need to call play as the previous event does it in its action method
   //_blind.process_event(play);

   // at this point, Play is active
   _blind.process_event(PlayerSm::pause);
   pstate(_blind);
   // go back to Playing
   _blind.process_event(end_pause);
   pstate(_blind);
   _blind.process_event(PlayerSm::pause);
   pstate(_blind);
   _blind.process_event(stop);
   pstate(_blind);
   // event leading to the same state
   // no action method called as none is defined in the transition table
   _blind.process_event(stop);
   pstate(_blind);
   // test call to no_transition
   _blind.process_event(PlayerSm::pause);
   pstate(_blind);
}

int main() {
test();
return 0;
}
