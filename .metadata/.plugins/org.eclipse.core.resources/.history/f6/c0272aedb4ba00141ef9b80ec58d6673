/*
 * main.cpp
 *
 *  Created on: Jan 25, 2015
 *      Author: micha
 */

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <boost/bind.hpp>
#include <functional>

#include "MockRoom.h"
#include "MockTime.h"
#include "MockInputUser.h"
#include "Switch.h"

using namespace std;
using namespace boost::gregorian;

using ::testing::_;
using ::testing::Return;
using ::testing::Invoke;
using ::testing::InvokeWithoutArgs;
using ::testing::TestWithParam;
using ::testing::Values;
using ::testing::StrCaseEq;

class SwitchTest: public ::testing::Test {
   protected:
      SwitchTest() :
            _room(0, "TestRoom", nullptr), _inputUser(0, "Test"), testString(
                  "Test"), testRoomString("TestRoom") {
      }

      virtual void SetUp() {
      }
      MockTime _time;
      MockRoom _room;
      MockInputUser _inputUser;
      std::string testString;
      std::string testRoomString;
};

TEST_F(SwitchTest, Constructor_OK) {
   Switch _switch(0, testString, nullptr);
   ASSERT_EQ(_switch.getId(), 0);
   ASSERT_STREQ(testString.c_str(), _switch.getName().c_str());
   ASSERT_EQ(_switch.getRoom(), nullptr);
}

TEST_F(SwitchTest, CopyConstructor_OK) {
   Switch _switch(0, testString, nullptr);
   Switch __switch(_switch);
   ASSERT_EQ(__switch.getId(), 0);
   ASSERT_STREQ(testString.c_str(), __switch.getName().c_str());
   ASSERT_EQ(__switch.getRoom(), nullptr);
}

TEST_F(SwitchTest, Assignment_OK) {
   Switch _switch(0, testString, nullptr);
   Switch __switch(1, "g", nullptr);
   __switch = _switch;
   ASSERT_EQ(__switch.getId(), 0);
   ASSERT_STREQ(testString.c_str(), __switch.getName().c_str());
   ASSERT_EQ(__switch.getRoom(), nullptr);
}

TEST_F(SwitchTest, ConstructorWithRoom_OK) {
   std::string ResultString("TestRoom_Test");
   Switch _switch(0, testString, &_room);
   ASSERT_EQ(_switch.getId(), 0);
   ASSERT_STREQ(ResultString.c_str(), _switch.getName().c_str());
   ASSERT_EQ(_switch.getRoom(), &_room);
}

TEST_F(SwitchTest, CopyConstructorWithRoom_OK) {
   std::string ResultString("TestRoom_Test");
   Switch _switch(0, testString, &_room);
   Switch __switch(_switch);
   ASSERT_EQ(__switch.getId(), 0);
   ASSERT_STREQ(ResultString.c_str(), __switch.getName().c_str());
   ASSERT_EQ(__switch.getRoom(), &_room);
}

TEST_F(SwitchTest, AssignmentWithRoom_OK) {
   std::string ResultString("TestRoom_Test");
   Switch _switch(0, testString, &_room);
   Switch __switch(1, "z", nullptr);
   __switch = _switch;
   ASSERT_EQ(__switch.getId(), 0);
   ASSERT_STREQ(ResultString.c_str(), __switch.getName().c_str());
   ASSERT_EQ(__switch.getRoom(), &_room);
}

TEST_F(SwitchTest, ShortPress_OK) {
   Switch _switch(1, "z", &_room);
   ptime PressTime(date(2002, Jan, 14));
   ptime ReleaseTime(date(2002, Jan, 14), millisec(500));
   EXPECT_CALL(_room, getTimeRef()).WillRepeatedly(Return(&_time));
   EXPECT_CALL(_time, getCurrentTime()).WillOnce(Return(PressTime));
   _switch.OnPress();
   EXPECT_CALL(_time, getCurrentTime()).WillOnce(Return(ReleaseTime));
   _switch.OnRelease();
}

TEST_F(SwitchTest, GetActionList_OK) {
   Switch _switch(1, "z", nullptr);
   EXPECT_EQ(0, _switch.getActionMap().size());
}

TEST_F(SwitchTest, AddOneActionOK) {
   Switch _switch(1, "z", nullptr);
   t_SwitchActionFunction sAf = boost::bind(&iInputUser::OnPress, _inputUser, _1);
   _switch.addAction(Pressed, sAf);
   EXPECT_EQ(1, _switch.getActionMap().size());
}

TEST_F(SwitchTest, AddTwoActionsOK) {
   Switch _switch(1, "z", nullptr);
   t_SwitchActionFunction sAf = std::bind(&iInputUser::OnPress, _inputUser, _1);
   _switch.addAction(Pressed, sAf);
   _switch.addAction(LongPressed, sAf);
   EXPECT_EQ(2, _switch.getActionMap().size());
}

TEST_F(SwitchTest, AddAllActionsOK) {
   Switch _switch(1, "z", nullptr);
   t_SwitchActionFunction sAf = std::bind(&iInputUser::OnPress, _inputUser, _1);
   for (int i = 0; i < NumOfSwitchStates; i++) {
      _switch.addAction((SwitchState) i, sAf);
   }
   EXPECT_EQ(NumOfSwitchStates, _switch.getActionMap().size());
}

TEST_F(SwitchTest, AddOneActionTwice_OK) {
   Switch _switch(1, "z", nullptr);
   t_SwitchActionFunction sAf = std::bind(&iInputUser::OnPress, _inputUser, _1);
   _switch.addAction(Pressed, sAf);
   _switch.addAction(Pressed, sAf);
   EXPECT_EQ(1, _switch.getActionMap().size());
}

TEST_F(SwitchTest, CheckActionPressedNoRoom_OK) {
   Switch _switch(1, "z", nullptr);
   t_SwitchActionFunction sAf = std::bind(&iInputUser::OnPress, _inputUser, _1);
   _switch.addAction(Pressed, sAf);
   EXPECT_CALL(_inputUser, OnPress(_)).Times(0);
   _switch.OnPress();
}

void TestPrint() {
   std::cout << "OnPress called" << std::endl;
}

TEST_F(SwitchTest, CheckActionPressed_OK) {
   Switch _switch(1, "z", &_room);
   EXPECT_CALL(_room, getTimeRef()).WillRepeatedly(Return(&_time));
   EXPECT_CALL(_inputUser, OnPress(_)).WillOnce(InvokeWithoutArgs(TestPrint));
   EXPECT_CALL(_time, getCurrentTime()).WillOnce(Return(second_clock::local_time()));
   t_SwitchActionFunction sAf = boost::bind(&iInputUser::OnPress, _inputUser, _1);
   _switch.addAction(Pressed, sAf);
   _switch.OnPress();
}
