//============================================================================
// Name        : FunctionTracer.cpp
// Author      : Michael Rossner
// Version     :
// Copyright   : LGPL2
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <string>
#include <iostream>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>

using namespace std;

#include <map>
#include <mutex> //cpp11
#include <iostream>

#include <time.h>

template <class K, class V, class Compare = std::less<K>, class Allocator = std::allocator<std::pair<const K, V> > >
class guarded_map {
private:
   std::map<K, V, Compare, Allocator> _map;
   std::mutex _m;

public:
   void set(K key, V value) {
      std::lock_guard<std::mutex> lk(this->_m);
      this->_map[key] = value;
   }

   V & get(K key) {
      std::lock_guard<std::mutex> lk(this->_m);
      return this->_map[key];
   }

   bool empty() {
      std::lock_guard<std::mutex> lk(this->_m);
      return this->_map.empty();
   }

   // other public methods you need to implement
};

guarded_map<int, int> FunctionTraceCounter;
int FunctionTrace_TraceLevel = 1000;

class FunctionTracer {
public:
   FunctionTracer(std::string name) :sFunctionName(name), EntryTraceDone(false), ExitTraceDone(false)
   {
      ThreadId = getpid();
      int Counter = FunctionTraceCounter.get(ThreadId);
      Counter++;
      if (Counter <= FunctionTrace_TraceLevel){
         std::cout << "Start FunctionName=" << sFunctionName << " - ThreadId = " << ThreadId << " - CallDepth = " << Counter << std::endl;
         if(-1 == clock_gettime(CLOCK_MONOTONIC_COARSE, &Entry_Clock_Time)) {
            perror( "clock gettime CLOCK_MONOTONIC_COARSE" );
         }
         if (-1 == clock_gettime(CLOCK_THREAD_CPUTIME_ID, &Entry_Cpu_Time)) {
            perror( "clock gettime CLOCK_THREAD_CPUTIME_ID" );
         }
         EntryTraceDone = true;
      }
      FunctionTraceCounter.set(ThreadId, Counter);
   }
   ~FunctionTracer(){Destructor();}

protected:
   std::string sFunctionName;
   bool EntryTraceDone;
   bool ExitTraceDone;
   int ThreadId;
   int Clock_EntryTime;
   timespec Entry_Cpu_Time, Entry_Clock_Time;

   void Destructor(){
      ThreadId = getpid();
      int Counter = FunctionTraceCounter.get(ThreadId);
      if (Counter <= FunctionTrace_TraceLevel){
         timespec Cpu_Time, Clock_Time;
         timespec Cpu_TimeResolution, Clock_TimeResolution;
         if (-1 == clock_gettime(CLOCK_MONOTONIC_COARSE, &Clock_Time)){
            perror("clock_gettime CLOCK_MONOTONIC_COARSE");
         }
         if (-1 == clock_getres(CLOCK_MONOTONIC_COARSE, &Clock_TimeResolution)){
            perror("clock_gettime CLOCK_MONOTONIC_COARSE");
         }
         if (-1 == clock_gettime(CLOCK_THREAD_CPUTIME_ID, &Cpu_Time)){
            perror("clock_gettime CLOCK_THREAD_CPUTIME_ID");
         }
         if (-1 == clock_getres(CLOCK_THREAD_CPUTIME_ID, &Cpu_TimeResolution)){
            perror("clock_gettime CLOCK_THREAD_CPUTIME_ID");
         }
         int Clock_Duration = Clock_Time.tv_nsec-Entry_Clock_Time.tv_nsec;
         int CPU_Duration = Cpu_Time.tv_nsec-Entry_Cpu_Time.tv_nsec;
         int Counter = FunctionTraceCounter.get(ThreadId);
         std::cout << "Ende FunctionName=" << sFunctionName << " - ThreadId = " << ThreadId << " - CallDepth = " << Counter << std::endl;
         std::cout << "Function used CPU for " << CPU_Duration / Cpu_TimeResolution.tv_nsec << "ms" << std::endl;
         std::cout << "Function Duration     " << Clock_Duration / Clock_TimeResolution.tv_nsec << "ms" << std::endl;
         ExitTraceDone = true;
      }
      Counter--;
      FunctionTraceCounter.set(ThreadId, Counter);
   }

};

#define FUNCTION_TRACE FunctionTracer fct(__FUNCTION__);

void test3()
{
   FUNCTION_TRACE
   std::cout << "test3 Ende" << std::endl;
}

void test2()
{
   FUNCTION_TRACE
   test3();
   std::cout << "test2 Ende" << std::endl;
}

void test1()
{
   FUNCTION_TRACE
   test2();
   std::cout << "test Ende" << std::endl;
}

int main() {
   FUNCTION_TRACE
	cout << "!!!Hello raspberry!!!" << endl; // prints !!!Hello raspberry!!!
   test1();
   std::cout << "main Ende" << std::endl;
	return 0;
}
